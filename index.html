<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Weaver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow: auto;
            background-image: url('wordweaver.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: -1;
        }

        .main-menu, .game-wrapper, .difficulty-menu {
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            width: 100%;
            align-items: center;
            justify-content: center;
            min-height: 400px;
        }

        .main-menu {
            background-color: transparent;
            box-shadow: none;
            min-height: 100%;
            padding: 0;
            position: relative;
            z-index: 0;
        }

        .main-menu h1, .difficulty-menu h1 {
            font-size: 3rem;
            font-weight: bold;
            color: #f49c20;
            margin-bottom: 30px;
            position: relative;
            z-index: 2;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8),
                         -1px -1px 2px rgba(255,255,255,0.2);
        }

        .main-menu h1 {
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7),
                         -1px -1px 2px rgba(255,255,255,0.3);
        }

        .menu-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 80%;
            max-width: 300px;
            position: relative;
            z-index: 2;
        }

        .menu-button {
            background-color: #007bff;
            color: white;
            padding: 15px 30px;
            border-radius: 30px;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 12px rgba(0, 123, 255, 0.4),
                         0 2px 4px rgba(0, 123, 255, 0.2);
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .menu-button:hover {
            background-color: #0056b3;
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 123, 255, 0.6),
                         0 3px 6px rgba(0, 123, 255, 0.4);
        }

        .menu-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.2);
            background-color: #004085;
        }

        .game-wrapper {
            flex-direction: column;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
            width: 100%;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .player-score {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 1.25rem;
            font-weight: bold;
            color: #f49c20;
        }

        .player-score span {
            font-size: 1.8rem;
            color: #4CAF50;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .board-container {
            display: grid;
            grid-template-columns: repeat(15, minmax(0, 1fr));
            grid-template-rows: repeat(15, minmax(0, 1fr));
            gap: 2px;
            background-color: #ccc;
            border-radius: 10px;
            overflow: hidden;
            width: clamp(300px, 80vw, 750px);
            height: clamp(300px, 80vw, 750px);
            margin: 0 auto;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .board-cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #d1b899;
            font-size: 0.75rem;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.4);
            position: relative;
            user-select: none;
            border-radius: 3px;
            text-align: center;
        }

        .double-letter { background-color: #a8d6e0; color: #007bb6; }
        .triple-letter { background-color: #a7d9ab; color: #28a745; }
        .double-word { background-color: #e0a8a8; color: #dc3545; }
        .triple-word { background-color: #d8a8e0; color: #6f42c1; }
        .quadruple-letter { background-color: #f7e2a5; color: #ffc107; }
        .quadruple-word { background-color: #facd89; color: #fd7e14; }
        .wild-card { background-color: #c9c9c9; color: #555; }
        .start-cell { background-color: #ffd700; color: #daaa00; }

        .tile {
            width: 90%;
            height: 90%;
            background-color: #ffe0b2;
            border: 1px solid #e0b284;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            user-select: none;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            cursor: grab;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 1px 2px rgba(0,0,0,0.2);
        }

        .tile:hover {
            transform: translateY(-2px);
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.3);
        }

        .tile.dragging {
            opacity: 0.7;
            cursor: grabbing;
            transform: scale(1.05);
            z-index: 1000;
        }

        .tile .tile-letter-display {
            font-size: 1.8rem;
            font-weight: bold;
            color: #5d4037;
            line-height: 1;
            margin-bottom: -0.2em;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
        }

        .tile-score {
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 0.7em;
            font-weight: bold;
            color: #795548;
            line-height: 1;
            text-shadow: 0.5px 0.5px 1px rgba(0,0,0,0.2);
        }

        .rack {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 10px;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.05);
            min-height: 80px;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
            max-width: 750px;
        }

        .rack .tile {
            width: 55px;
            height: 55px;
            font-size: 1.5rem;
        }

        .buttons-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
            width: 100%;
            max-width: 750px;
        }

        .game-button {
            background-color: #007bff;
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 10px rgba(0, 123, 255, 0.5),
                         0 2px 4px rgba(0, 123, 255, 0.3);
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .game-button:hover {
            background-color: #0056b3;
            transform: translateY(-3px);
            box-shadow: 0 7px 14px rgba(0, 123, 255, 0.6),
                         0 3px 6px rgba(0, 123, 255, 0.4);
        }

        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.2);
            background-color: #004085;
        }

        .game-button.pass {
            background-color: #6c757d;
            box-shadow: 0 5px 10px rgba(108, 117, 125, 0.5),
                         0 2px 4px rgba(108, 117, 125, 0.3);
        }
        .game-button.pass:hover {
            background-color: #5a6268;
            box-shadow: 0 7px 14px rgba(108, 117, 125, 0.6),
                         0 3px 6px rgba(108, 117, 125, 0.4);
        }

        .game-button.shuffle {
            background-color: #ffc107;
            color: #333;
            box-shadow: 0 5px 10px rgba(255, 193, 7, 0.5),
                         0 2px 4px rgba(255, 193, 7, 0.3);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .game-button.shuffle:hover {
            background-color: #e0a800;
            box-shadow: 0 7px 14px rgba(255, 193, 7, 0.6),
                         0 3px 6px rgba(255, 193, 7, 0.4);
        }

        .game-button.exchange {
            background-color: #17a2b8;
            box-shadow: 0 5px 10px rgba(23, 162, 184, 0.5),
                         0 2px 4px rgba(23, 162, 184, 0.3);
        }
        .game-button.exchange:hover {
            background-color: #138496;
            box-shadow: 0 7px 14px rgba(23, 162, 184, 0.6),
                         0 3px 6px rgba(23, 162, 184, 0.4);
        }

        .message-box {
            background-color: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #f5c6cb;
            margin-top: 20px;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 750px;
            text-shadow: 0.5px 0.5px 1px rgba(0,0,0,0.2);
        }

        .message-box.show {
            opacity: 1;
        }

        .current-player-indicator {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            width: fit-content;
            padding: 8px 15px;
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            margin-left: auto;
            margin-right: auto;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            width: 80%;
            max-width: 500px;
            text-align: center;
            text-shadow: 0.5px 0.5px 1px rgba(0,0,0,0.2);
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .rack-tile-for-exchange {
            cursor: pointer;
            border: 1px solid #e0b284;
        }

        .rack-tile-for-exchange.selected-for-exchange {
            border: 4px solid #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
        }

        @media (min-width: 768px) {
            .game-wrapper {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="main-menu" class="main-menu">
        <h1>Word Weaver</h1>
        <div class="menu-buttons-container">
            <button class="menu-button" id="one-player-btn">One Player (vs. AI)</button>
            <button class="menu-button" id="two-player-btn">Two Players</button>
        </div>
    </div>

    <div id="difficulty-menu" class="difficulty-menu hidden">
        <h1>Choose AI Difficulty</h1>
        <div class="menu-buttons-container">
            <button class="menu-button" id="difficulty-easy-btn">Easy</button>
            <button class="menu-button" id="difficulty-medium-btn">Medium</button>
            <button class="menu-button" id="difficulty-hard-btn">Hard</button>
            <button class="menu-button" id="difficulty-back-btn">Back to Main Menu</button>
        </div>
    </div>

    <div id="game-wrapper" class="game-wrapper hidden">
        <div class="game-header">
            <div class="player-score">
                Player 1 Score: <span id="player1-score">0</span>
            </div>
            <div class="player-score">
                Player <span id="player2-label">2</span> Score: <span id="player2-score">0</span>
            </div>
        </div>

        <div id="game-board" class="board-container">
        </div>

        <div class="current-player-indicator" id="current-player-display">Player 1's Turn</div>

        <div class="rack" id="player-rack">
        </div>

        <div class="buttons-container">
            <button class="game-button" id="submit-word-btn">Submit Word</button>
            <button class="game-button pass" id="pass-turn-btn">Pass Turn</button>
            <button class="game-button shuffle" id="shuffle-tiles-btn">Shuffle Rack</button>
            <button class="game-button exchange" id="exchange-tiles-btn">Exchange Tiles</button>
            <button class="game-button" id="new-game-btn">New Game</button>
        </div>

        <div class="message-box" id="message-box"></div>
    </div>

    <div id="game-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="close-modal-btn">&times;</span>
            <p id="modal-message"></p>
            <button class="game-button mt-4" id="modal-ok-btn">OK</button>
        </div>
    </div>

    <div id="exchange-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="close-exchange-modal-btn">&times;</span>
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Select Tiles to Exchange</h2>
            <p class="mb-4 text-gray-600">Click on tiles to select/deselect them. You must exchange at least one tile.</p>
            <div id="exchange-tile-selection-container" class="flex flex-wrap justify-center gap-2 p-4 border rounded-lg bg-gray-50 mb-4">
            </div>
            <div class="flex justify-center gap-4">
                <button class="game-button bg-green-500 hover:bg-green-600 focus:ring-green-500" id="confirm-exchange-btn" disabled>Confirm Exchange</button>
                <button class="game-button pass" id="cancel-exchange-btn">Cancel</button>
            </div>
        </div>
    </div>

    <div id="blank-tile-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Choose a letter for the blank tile</h2>
            <p class="mb-4 text-gray-600">This blank tile will take on the properties of the letter you choose, but will always score 0 points.</p>
            <div id="blank-tile-letter-selection" class="flex flex-wrap justify-center gap-2 p-4 border rounded-lg bg-gray-50 mb-4">
            </div>
            <button class="game-button pass" id="cancel-blank-tile-selection-btn">Cancel</button>
        </div>
    </div>

    <audio id="tileClickSound" src="tileclick.mp3" preload="auto"></audio>
    <audio id="gotWordSound" src="gotword.mp3" preload="auto"></audio>
    <audio id="notWordSound" src="notword.mp3" preload="auto"></audio>
    <audio id="fiftyPointsSound" src="50points.mp3" preload="auto"></audio>
    <audio id="hundredPointsSound" src="100points.mp3" preload="auto"></audio>

    <script>
        const BOARD_SIZE = 15;
        const RACK_SIZE = 7;
        const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        const TILE_DISTRIBUTION = {
            'A': [9, 1], 'B': [2, 3], 'C': [2, 3], 'D': [4, 2], 'E': [12, 1],
            'F': [2, 4], 'G': [3, 2], 'H': [2, 4], 'I': [9, 1], 'J': [1, 8],
            'K': [1, 5], 'L': [4, 1], 'M': [2, 3], 'N': [6, 1], 'O': [8, 1],
            'P': [2, 3], 'Q': [1, 10], 'R': [6, 1], 'S': [4, 1], 'T': [6, 1],
            'U': [4, 1], 'V': [2, 4], 'W': [2, 4], 'X': [1, 8], 'Y': [2, 4],
            'Z': [1, 10], '_': [2, 0]
        };

        const BONUS_COUNTS = {
            'triple-word': 8,
            'double-word': 16,
            'triple-letter': 12,
            'double-letter': 24,
            'quadruple-letter': 4,
            'quadruple-word': 4,
            'wild-card': 4
        };

        let tileBag = [];
        let board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
        let playerRacks = [[], []];
        let playerScores = [0, 0];
        let currentPlayer = 0;
        let gameMode = 'two-player';
        let aiDifficulty = 'easy';
        let currentBonusSquares = {};

        let draggedTile = null;
        let draggedTileData = null;
        let originalParent = null;
        let placedTiles = [];

        const mainMenu = document.getElementById('main-menu');
        const difficultyMenu = document.getElementById('difficulty-menu');
        const gameWrapper = document.getElementById('game-wrapper');
        const onePlayerBtn = document.getElementById('one-player-btn');
        const twoPlayerBtn = document.getElementById('two-player-btn');
        const difficultyEasyBtn = document.getElementById('difficulty-easy-btn');
        const difficultyMediumBtn = document.getElementById('difficulty-medium-btn');
        const difficultyHardBtn = document.getElementById('difficulty-hard-btn');
        const difficultyBackBtn = document.getElementById('difficulty-back-btn');
        const gameBoardElement = document.getElementById('game-board');
        const playerRackElement = document.getElementById('player-rack');
        const player1ScoreElement = document.getElementById('player1-score');
        const player2ScoreElement = document.getElementById('player2-score');
        const player2Label = document.getElementById('player2-label');
        const submitWordBtn = document.getElementById('submit-word-btn');
        const passTurnBtn = document.getElementById('pass-turn-btn');
        const shuffleTilesBtn = document.getElementById('shuffle-tiles-btn');
        const exchangeTilesBtn = document.getElementById('exchange-tiles-btn');
        const newGameBtn = document.getElementById('new-game-btn');
        const messageBox = document.getElementById('message-box');
        const currentPlayerDisplay = document.getElementById('current-player-display');

        const gameModal = document.getElementById('game-modal');
        const modalMessage = document.getElementById('modal-message');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const modalOkBtn = document.getElementById('modal-ok-btn');

        const exchangeModal = document.getElementById('exchange-modal');
        const closeExchangeModalBtn = document.getElementById('close-exchange-modal-btn');
        const exchangeTileSelectionContainer = document.getElementById('exchange-tile-selection-container');
        const confirmExchangeBtn = document.getElementById('confirm-exchange-btn');
        const cancelExchangeBtn = document.getElementById('cancel-exchange-btn');

        let selectedTilesForExchange = [];

        const blankTileModal = document.getElementById('blank-tile-modal');
        const blankTileLetterSelectionContainer = document.getElementById('blank-tile-letter-selection');
        const cancelBlankTileSelectionBtn = document.getElementById('cancel-blank-tile-selection-btn');
        let currentBlankTileElement = null;

        // Corrected: Embedded dictionary for a self-contained game.
        const DICTIONARY_WORDS = [
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "CAT", "DOG", "SUN", "MOON", "STAR", "APPLE", "HOUSE", "CAR", "BOOK", "PEN",
            "JAZZ", "QUIZ", "GLOW", "AXIOM", "JUXTAPOSE", "RHYTHM", "FUZZY", "QUACK",
            "AERIE", "ZEALOT", "BOXING", "CRAZY", "EQUATOR", "FLIP", "GASP", "HERO",
            "IDEA", "KITE", "LAMP", "MOVIE", "NIGHT", "ORANGE", "PINE", "QUICK",
            "RIVER", "SQUARE", "TENT", "UNDER", "VIOLIN", "WINDOW", "XRAY", "YARD", "ZOO"
        ];
        let VALID_WORDS = new Set();
        let isDictionaryLoaded = false;

        const tileClickAudio = document.getElementById('tileClickSound');
        const gotWordAudio = document.getElementById('gotWordSound');
        const notWordAudio = document.getElementById('notWordSound');
        const fiftyPointsAudio = document.getElementById('fiftyPointsSound');
        const hundredPointsAudio = document.getElementById('hundredPointsSound');

        function playMP3Sound() {
            if (tileClickAudio) {
                tileClickAudio.load();
                tileClickAudio.currentTime = 0;
                tileClickAudio.volume = 0.3;
                tileClickAudio.play().catch(e => console.warn("Error playing tile click sound:", e));
            }
        }

        function playGotWordSound() {
            if (gotWordAudio) {
                gotWordAudio.load();
                gotWordAudio.currentTime = 0;
                gotWordAudio.volume = 0.5;
                gotWordAudio.play().catch(e => console.warn("Error playing got word sound:", e));
            }
        }

        function playNotWordSound() {
            if (notWordAudio) {
                notWordAudio.load();
                notWordAudio.currentTime = 0;
                notWordAudio.volume = 0.5;
                notWordAudio.play().catch(e => console.warn("Error playing not word sound:", e));
            }
        }

        function playFiftyPointsSound() {
            if (fiftyPointsAudio) {
                fiftyPointsAudio.load();
                fiftyPointsAudio.currentTime = 0;
                fiftyPointsAudio.volume = 0.5;
                fiftyPointsAudio.play().catch(e => console.warn("Error playing 50 points sound:", e));
            }
        }

        function playHundredPointsSound() {
            if (hundredPointsAudio) {
                hundredPointsAudio.load();
                hundredPointsAudio.currentTime = 0;
                hundredPointsAudio.volume = 0.5;
                hundredPointsAudio.play().catch(e => console.warn("Error playing 100 points sound:", e));
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showMessageBox(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = `message-box show`;
            if (type === 'success') {
                messageBox.classList.add('bg-green-100', 'text-green-700', 'border-green-400');
            } else if (type === 'info') {
                messageBox.classList.add('bg-blue-100', 'text-blue-700', 'border-blue-400');
            } else {
                messageBox.classList.add('bg-red-100', 'text-red-700', 'border-red-400');
            }
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000);
        }

        function showModal(message, onOkCallback = null) {
            modalMessage.textContent = message;
            gameModal.style.display = 'flex';

            modalOkBtn.onclick = () => {
                gameModal.style.display = 'none';
                if (onOkCallback) {
                    onOkCallback();
                }
            };

            closeModalBtn.onclick = () => {
                gameModal.style.display = 'none';
            };

            gameModal.onclick = (event) => {
                if (event.target === gameModal) {
                    gameModal.style.display = 'none';
                }
            };
        }

        function getBonusLabel(bonusType) {
            switch (bonusType) {
                case 'double-letter': return 'DL';
                case 'triple-letter': return 'TL';
                case 'double-word': return 'DW';
                case 'triple-word': return 'TW';
                case 'quadruple-letter': return 'QL';
                case 'quadruple-word': return 'QW';
                case 'wild-card': return 'WC';
                case 'start-cell': return '⭐';
                default: return '';
            }
        }

        // Corrected: The loadDictionary function now loads a hard-coded dictionary array.
        function loadDictionary() {
            VALID_WORDS = new Set(DICTIONARY_WORDS.map(word => word.toUpperCase()));
            isDictionaryLoaded = true;
            showMessageBox(`Dictionary loaded with ${VALID_WORDS.size} words!`, 'success');
        }


        function createTileBag() {
            tileBag = [];
            for (const letter in TILE_DISTRIBUTION) {
                const [count, points] = TILE_DISTRIBUTION[letter];
                for (let i = 0; i < count; i++) {
                    tileBag.push({ letter: letter, points: points });
                }
            }
            shuffleArray(tileBag);
        }

        function drawTilesToRack(playerIdx, count) {
            for (let i = 0; i < count && tileBag.length > 0; i++) {
                const tile = tileBag.pop();
                playerRacks[playerIdx].push(tile);
            }
            renderRack(playerIdx);
        }

        function generateRandomBonusSquares() {
            currentBonusSquares = {};
            const availableCells = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (!(r === 7 && c === 7)) {
                        availableCells.push(`${r},${c}`);
                    }
                }
            }
            shuffleArray(availableCells);

            currentBonusSquares['7,7'] = 'start-cell';

            for (const bonusType in BONUS_COUNTS) {
                let count = BONUS_COUNTS[bonusType];
                if (bonusType === 'double-word') {
                    count -= 1;
                }

                for (let i = 0; i < count; i++) {
                    if (availableCells.length > 0) {
                        const cellCoords = availableCells.pop();
                        currentBonusSquares[cellCoords] = bonusType;
                    } else {
                        console.warn(`Not enough unique cells to place all ${bonusType} bonuses.`);
                        break;
                    }
                }
            }
        }

        function renderBoard() {
            gameBoardElement.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('board-cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.id = `cell-${r}-${c}`;

                    const bonusType = currentBonusSquares[`${r},${c}`];
                    if (bonusType) {
                        cell.classList.add(bonusType);
                        cell.textContent = getBonusLabel(bonusType);
                    }

                    if (board[r][c]) {
                        const tileElement = createTileElement(board[r][c]);
                        tileElement.dataset.permanent = 'true';
                        tileElement.draggable = false;
                        tileElement.removeEventListener('click', handleTileClick);
                        cell.innerHTML = '';
                        cell.appendChild(tileElement);
                    }

                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('drop', handleDrop);
                    gameBoardElement.appendChild(cell);
                }
            }
        }

        function createTileElement(tileObject) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.draggable = true;

            tile.dataset.originalLetter = tileObject.letter;
            tile.dataset.points = tileObject.points;

            let displayLetter = tileObject.letter;
            if (tileObject.letter === '_') {
                if (tileObject.assignedLetterForTurn) {
                    displayLetter = tileObject.assignedLetterForTurn;
                    tile.dataset.assignedLetter = tileObject.assignedLetterForTurn;
                } else {
                    displayLetter = '';
                }
            }
            
            const letterDisplay = document.createElement('div');
            letterDisplay.classList.add('tile-letter-display');
            letterDisplay.textContent = displayLetter;

            const scoreDisplay = document.createElement('div');
            scoreDisplay.classList.add('tile-score');
            scoreDisplay.textContent = tileObject.points;

            tile.appendChild(letterDisplay);
            tile.appendChild(scoreDisplay);

            tile.addEventListener('dragstart', handleDragStart);
            tile.addEventListener('dragend', handleDragEnd);
            tile.addEventListener('click', handleTileClick);
            return tile;
        }

        function renderRack(playerIdx) {
            playerRackElement.innerHTML = '';
            playerRacks[playerIdx].forEach(tileObject => {
                const tileElement = createTileElement(tileObject);
                playerRackElement.appendChild(tileElement);
            });
            updateCurrentPlayerDisplay();
        }

        function updateGameDisplay() {
            player1ScoreElement.textContent = playerScores[0];
            player2ScoreElement.textContent = playerScores[1];
            if (gameMode === 'one-player') {
                player2Label.textContent = 'AI';
            } else {
                player2Label.textContent = '2';
            }
            renderRack(currentPlayer);
        }

        function updateCurrentPlayerDisplay() {
            if (gameMode === 'one-player' && currentPlayer === 1) {
                currentPlayerDisplay.textContent = `AI's Turn (${aiDifficulty.toUpperCase()})`;
                currentPlayerDisplay.style.color = '#dc3545';
            } else {
                currentPlayerDisplay.textContent = `Player ${currentPlayer + 1}'s Turn`;
                if (currentPlayer === 0) {
                    currentPlayerDisplay.style.color = '#007bff';
                } else {
                    currentPlayerDisplay.style.color = '#dc3545';
                }
            }
        }

        function initializeGame() {
            tileBag = [];
            board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
            playerRacks = [[], []];
            playerScores = [0, 0];
            currentPlayer = 0;
            placedTiles = [];

            createTileBag();
            generateRandomBonusSquares();
            drawTilesToRack(0, RACK_SIZE);
            drawTilesToRack(1, RACK_SIZE);
            renderBoard();
            updateGameDisplay();

            if (gameMode === 'one-player' && currentPlayer === 1) {
                setTimeout(makeAIMove, 1000);
            }
            showMessageBox('Game Started!', 'info');
        }

        function handleDragStart(e) {
            const tileElement = e.target;
            if ((gameMode === 'one-player' && currentPlayer === 1) || (tileElement.dataset.permanent === 'true')) {
                e.preventDefault();
                return;
            }

            const originalRackIndex = Array.from(playerRackElement.children).indexOf(tileElement);

            if (originalRackIndex === -1) {
                if (tileElement.dataset.tempRow && tileElement.dataset.tempCol) {
                    const r = parseInt(tileElement.dataset.tempRow);
                    const c = parseInt(tileElement.dataset.tempCol);
                    const foundPlacedTile = placedTiles.find(p => p.r === r && p.c === c && p.tileElement === tileElement);
                    if (foundPlacedTile) {
                        draggedTileData = foundPlacedTile.tileObj;
                    } else {
                        console.error("Dragged tile on board not found in placedTiles array. Preventing drag.");
                        e.preventDefault();
                        return;
                    }
                } else {
                    console.error("Dragged tile not found in current player's rack or not a valid temporary board tile. Preventing drag.");
                    e.preventDefault();
                    return;
                }
            } else {
                draggedTileData = playerRacks[currentPlayer][originalRackIndex];
            }

            draggedTile = tileElement;
            originalParent = tileElement.parentNode;
            const letterToTransfer = draggedTileData.assignedLetterForTurn || draggedTileData.letter;
            e.dataTransfer.setData('text/plain', letterToTransfer);
            tileElement.classList.add('dragging');
            setTimeout(() => { tileElement.style.opacity = '0'; }, 0);
            playMP3Sound();
        }

        function handleDragEnd(e) {
            if (e.target) {
                e.target.classList.remove('dragging');
                e.target.style.opacity = '1';
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDrop(e) {
            e.preventDefault();
            const target = e.target.closest('.board-cell, .rack');

            if (!draggedTile || !draggedTileData || !target) {
                if (draggedTile && originalParent) {
                    originalParent.appendChild(draggedTile);
                    if (draggedTileData && draggedTileData.letter === '_') {
                        draggedTileData.assignedLetterForTurn = null;
                        draggedTile.querySelector('.tile-letter-display').textContent = '';
                        delete draggedTile.dataset.assignedLetter;
                    }
                }
                showMessageBox('Invalid drop target or operation.', 'error');
                draggedTile = null;
                draggedTileData = null;
                originalParent = null;
                return;
            }

            const currentRack = playerRackElement;

            if (target.classList.contains('board-cell')) {
                const row = parseInt(target.dataset.row);
                const col = parseInt(target.dataset.col);

                if (board[row][col] !== null) {
                    showMessageBox('Cell already occupied!');
                    originalParent.appendChild(draggedTile);
                    if (draggedTileData && draggedTileData.letter === '_') {
                        draggedTileData.assignedLetterForTurn = null;
                        draggedTile.querySelector('.tile-letter-display').textContent = '';
                        delete draggedTile.dataset.assignedLetter;
                    }
                    draggedTile = null;
                    draggedTileData = null;
                    originalParent = null;
                    return;
                }

                if (draggedTileData.letter === '_') {
                    target.innerHTML = '';
                    target.appendChild(draggedTile);
                    playMP3Sound();

                    showLetterSelectionModal(draggedTile, (chosenLetter) => {
                        draggedTileData.assignedLetterForTurn = chosenLetter;
                        draggedTile.querySelector('.tile-letter-display').textContent = chosenLetter;
                        draggedTile.dataset.assignedLetter = chosenLetter;

                        if (originalParent === currentRack) {
                            const indexInRack = playerRacks[currentPlayer].indexOf(draggedTileData);
                            if (indexInRack > -1) {
                                playerRacks[currentPlayer].splice(indexInRack, 1);
                            }
                        } else if (draggedTile.dataset.tempRow && draggedTile.dataset.tempCol) {
                            const oldRow = parseInt(draggedTile.dataset.tempRow);
                            const oldCol = parseInt(draggedTile.dataset.tempCol);
                            board[oldRow][oldCol] = null;
                            const oldCellElement = document.getElementById(`cell-${oldRow}-${oldCol}`);
                            oldCellElement.innerHTML = '';
                            const oldBonusType = currentBonusSquares[`${oldRow},${oldCol}`];
                            if (oldBonusType) { oldCellElement.textContent = getBonusLabel(oldBonusType); }
                            placedTiles = placedTiles.filter(p => p.tileElement !== draggedTile);
                        }

                        board[row][col] = {
                            letter: draggedTileData.letter,
                            points: draggedTileData.points,
                            assignedLetter: draggedTileData.assignedLetterForTurn
                        };
                        draggedTile.dataset.tempRow = row;
                        draggedTile.dataset.col = col;
                        placedTiles.push({ r: row, c: col, tileObj: draggedTileData, tileElement: draggedTile });
                        showMessageBox(`Blank tile assigned to '${chosenLetter}' and placed at (${row},${col})`, 'info');

                        draggedTile = null;
                        draggedTileData = null;
                        originalParent = null;

                    }, () => {
                        if (originalParent) {
                            originalParent.appendChild(draggedTile);
                            draggedTileData.assignedLetterForTurn = null;
                            draggedTile.querySelector('.tile-letter-display').textContent = '';
                            delete draggedTile.dataset.assignedLetter;
                            showMessageBox('Blank tile placement cancelled. Returned to rack.', 'info');
                        } else {
                            console.error("Original parent missing after blank tile cancel.");
                            draggedTileData.assignedLetterForTurn = null;
                            draggedTile.remove();
                        }
                        draggedTile = null;
                        draggedTileData = null;
                        originalParent = null;

                        renderRack(currentPlayer);
                        renderBoard();
                    });
                    return;
                }

                if (originalParent === currentRack) {
                    const indexInRack = playerRacks[currentPlayer].indexOf(draggedTileData);
                    if (indexInRack > -1) {
                        playerRacks[currentPlayer].splice(indexInRack, 1);
                    }
                } else if (draggedTile.dataset.tempRow && draggedTile.dataset.tempCol) {
                    const oldRow = parseInt(draggedTile.dataset.tempRow);
                    const oldCol = parseInt(draggedTile.dataset.tempCol);
                    board[oldRow][oldCol] = null;
                    const cellElement = document.getElementById(`cell-${oldRow}-${oldCol}`);
                    cellElement.innerHTML = '';
                    const bonusType = currentBonusSquares[`${oldRow},${oldCol}`];
                    if (bonusType) { cellElement.textContent = getBonusLabel(bonusType); }
                    placedTiles = placedTiles.filter(p => p.tileElement !== draggedTile);
                }

                board[row][col] = {
                    letter: draggedTileData.letter,
                    points: draggedTileData.points,
                    assignedLetter: draggedTileData.assignedLetter || draggedTileData.assignedLetterForTurn || null
                };

                draggedTile.dataset.tempRow = row;
                draggedTile.dataset.col = col;
                placedTiles.push({ r: row, c: col, tileObj: draggedTileData, tileElement: draggedTile });

                target.innerHTML = '';
                target.appendChild(draggedTile);
                playMP3Sound();
                showMessageBox(`Tile ${draggedTileData.letter === '_' ? (draggedTileData.assignedLetterForTurn || 'blank') : draggedTileData.letter} placed at (${row},${col})`, 'info');

                draggedTile = null;
                draggedTileData = null;
                originalParent = null;

            } else if (target === currentRack) {
                if (draggedTile.dataset.tempRow && draggedTile.dataset.tempCol) {
                    const oldRow = parseInt(draggedTile.dataset.tempRow);
                    const oldCol = parseInt(draggedTile.dataset.tempCol);
                    board[oldRow][oldCol] = null;
                    const cellElement = document.getElementById(`cell-${oldRow}-${oldCol}`);
                    cellElement.innerHTML = '';
                    const bonusType = currentBonusSquares[`${oldRow},${oldCol}`];
                    if (bonusType) { cellElement.textContent = getBonusLabel(bonusType); }

                    placedTiles = placedTiles.filter(p => p.tileElement !== draggedTile);
                }

                if (draggedTileData && draggedTileData.letter === '_') {
                    draggedTileData.assignedLetterForTurn = null;
                    draggedTile.querySelector('.tile-letter-display').textContent = '';
                    delete draggedTile.dataset.assignedLetter;
                }
                if (!playerRacks[currentPlayer].includes(draggedTileData)) {
                    playerRacks[currentPlayer].push(draggedTileData);
                }

                delete draggedTile.dataset.tempRow;
                delete draggedTile.dataset.tempCol;

                renderRack(currentPlayer);
                playMP3Sound();
                showMessageBox('Tile moved back to rack.', 'info');

                draggedTile = null;
                draggedTileData = null;
                originalParent = null;
            } else {
                originalParent.appendChild(draggedTile);
                if (draggedTileData && draggedTileData.letter === '_') {
                    draggedTileData.assignedLetterForTurn = null;
                    draggedTile.querySelector('.tile-letter-display').textContent = '';
                    delete draggedTile.dataset.assignedLetter;
                }
                showMessageBox('Invalid drop zone. Tile returned to its original place.', 'error');
                draggedTile = null;
                draggedTileData = null;
                originalParent = null;
            }
        }

        function handleTileClick(e) {
            const clickedTile = e.target.closest('.tile');
            if (!clickedTile) return;

            if (clickedTile.dataset.permanent !== 'true' && clickedTile.dataset.tempRow && clickedTile.dataset.tempCol) {
                if (gameMode === 'one-player' && currentPlayer === 1) {
                    showMessageBox("You can't move AI's tiles!", 'error');
                    return;
                }

                const r = parseInt(clickedTile.dataset.tempRow);
                const c = parseInt(clickedTile.dataset.tempCol);

                const tileObjToRevert = board[r][c];

                if (!tileObjToRevert) {
                    console.error(`Could not find tile object at board position (${r},${c}) for clicked DOM element.`);
                    return;
                }
                
                board[r][c] = null;

                if (tileObjToRevert.letter === '_') {
                    tileObjToRevert.assignedLetterForTurn = null;
                    delete clickedTile.dataset.assignedLetter;
                    clickedTile.querySelector('.tile-letter-display').textContent = '';
                }
                playerRacks[currentPlayer].push(tileObjToRevert);

                const cellElement = document.getElementById(`cell-${r}-${c}`);
                cellElement.innerHTML = '';
                const bonusType = currentBonusSquares[`${r},${c}`];
                if (bonusType) { cellElement.textContent = getBonusLabel(bonusType); }

                placedTiles = placedTiles.filter(p => p.tileElement !== clickedTile);
                delete clickedTile.dataset.tempRow;
                delete clickedTile.dataset.tempCol;

                renderRack(currentPlayer);
                playMP3Sound();
                showMessageBox('Tile moved back to rack.', 'info');
            }
        }


        function validateAndScoreWords(currentBoard, tilesToValidate) {
            if (tilesToValidate.length === 0) {
                return null;
            }

            tilesToValidate.sort((a, b) => {
                const rowA = a.r;
                const colA = a.c;
                const rowB = b.r;
                const colB = b.c;
                if (rowA !== rowB) return rowA - rowB;
                return colA - colB;
            });

            let firstTileRow = tilesToValidate[0].r;
            let firstTileCol = tilesToValidate[0].c;

            let isHorizontal = true;
            let isVertical = true;
            if (tilesToValidate.length > 1) {
                for (let i = 1; i < tilesToValidate.length; i++) {
                    const row1 = tilesToValidate[i-1].r;
                    const col1 = tilesToValidate[i-1].c;
                    const row2 = tilesToValidate[i].r;
                    const col2 = tilesToValidate[i].c;
                    if (row1 !== row2) isHorizontal = false;
                    if (col1 !== col2) isVertical = false;
                }
            } else {
                isHorizontal = true;
                isVertical = true;
            }

            if (!isHorizontal && !isVertical) {
                return null;
            }
            if (isHorizontal && isVertical && tilesToValidate.length > 1) {
                return null;
            }

            if (tilesToValidate.length > 1) {
                if (isHorizontal) {
                    const row = tilesToValidate[0].r;
                    const startCol = tilesToValidate[0].c;
                    const endCol = tilesToValidate[tilesToValidate.length - 1].c;
                    for (let c = startCol; c <= endCol; c++) {
                        const isOccupied = tilesToValidate.some(t => t.r === row && t.c === c) || currentBoard[row][c] !== null;
                        if (!isOccupied) {
                            return null;
                        }
                    }
                } else {
                    const col = tilesToValidate[0].c;
                    const startRow = tilesToValidate[0].r;
                    const endRow = tilesToValidate[tilesToValidate.length - 1].r;
                    for (let r = startRow; r <= endRow; r++) {
                        const isOccupied = tilesToValidate.some(t => t.r === r && t.c === col) || currentBoard[r][col] !== null;
                        if (!isOccupied) {
                            return null;
                        }
                    }
                }
            }

            let connectedToExisting = false;
            let isFirstMove = true;
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if(currentBoard[r][c] !== null && !tilesToValidate.some(t => t.r === r && t.c === c)) {
                        isFirstMove = false;
                        break;
                    }
                }
                if (!isFirstMove) break;
            }

            if (isFirstMove) {
                const coversStartCell = tilesToValidate.some(tile => tile.r === 7 && tile.c === 7);
                if (!coversStartCell) {
                    return null;
                }
            } else {
                for (const pTile of tilesToValidate) {
                    const r = pTile.r;
                    const c = pTile.c;
                    const neighbors = [[r-1, c], [r+1, c], [r, c-1], [r, c+1]];
                    for (const [nr, nc] of neighbors) {
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                            const isNeighborNewlyPlaced = tilesToValidate.some(t => t.r === nr && t.c === nc);
                            if (currentBoard[nr][nc] !== null && !isNeighborNewlyPlaced) {
                                connectedToExisting = true;
                                break;
                            }
                        }
                    }
                    if (connectedToExisting) break;
                }
                if (!connectedToExisting) {
                    return null;
                }
            }

            let totalScore = 0;
            const formedWords = new Set();

            const getFullWord = (r, c, direction, boardState) => {
                let word = '';
                let wordTiles = [];
                let startR = r, startC = c;

                if (direction === 'horizontal') {
                    while (startC > 0 && boardState[r][startC - 1]) {
                        startC--;
                    }
                } else {
                    while (startR > 0 && boardState[startR - 1][c]) {
                        startR--;
                    }
                }

                let currentR = startR, currentC = startC;
                while (currentR < BOARD_SIZE && currentC < BOARD_SIZE && boardState[currentR][currentC]) {
                    const effectiveLetter = boardState[currentR][currentC].assignedLetter || boardState[currentR][currentC].letter;
                    word += effectiveLetter;
                    wordTiles.push({ r: currentR, c: currentC });
                    if (direction === 'horizontal') currentC++;
                    else currentR++;
                }
                return { word, wordTiles };
            };

            let wordsToScore = [];

            const isSingleTile = tilesToValidate.length === 1;
            const primaryTile = tilesToValidate[0];

            if (isHorizontal) {
                const { word, wordTiles } = getFullWord(primaryTile.r, primaryTile.c, 'horizontal', currentBoard);
                if (wordTiles.length > (isSingleTile ? 1 : 0)) {
                    wordsToScore.push({ word, tiles: wordTiles, direction: 'horizontal' });
                }
            }
            if (isVertical) {
                const { word, wordTiles } = getFullWord(primaryTile.r, primaryTile.c, 'vertical', currentBoard);
                if (wordTiles.length > (isSingleTile ? 1 : 0) && !(isSingleTile && isHorizontal && wordsToScore[0] && wordsToScore[0].word.toUpperCase() === word.toUpperCase())) {
                    wordsToScore.push({ word, tiles: wordTiles, direction: 'vertical' });
                }
            }

            if (wordsToScore.length === 0) {
                return null;
            }

            for (const { word: currentWord, tiles: currentWordTiles } of wordsToScore) {
                if (!VALID_WORDS.has(currentWord.toUpperCase())) {
                    return null;
                }
                formedWords.add(currentWord);

                let wordScore = 0;
                let wordMultiplier = 1;

                for (const { r, c } of currentWordTiles) {
                    const bonusType = currentBonusSquares[`${r},${c}`];
                    const tileInBoard = currentBoard[r][c];
                    let tilePoints = tileInBoard.points;

                    const isNewlyPlacedInThisMove = tilesToValidate.some(t => t.r === r && t.c === c);

                    let letterMultiplier = 1;
                    if (isNewlyPlacedInThisMove) {
                        if (bonusType === 'double-letter') letterMultiplier = 2;
                        if (bonusType === 'triple-letter') letterMultiplier = 3;
                        if (bonusType === 'quadruple-letter') letterMultiplier = 4;
                        if (bonusType === 'double-word' || bonusType === 'start-cell') wordMultiplier *= 2;
                        if (bonusType === 'triple-word') wordMultiplier *= 3;
                        if (bonusType === 'quadruple-word') wordMultiplier *= 4;
                    }

                    if (tileInBoard.letter === '_') {
                        tilePoints = 0;
                    }

                    wordScore += tilePoints * letterMultiplier;
                }
                wordScore *= wordMultiplier;
                totalScore += wordScore;
            }

            if (tilesToValidate.length === RACK_SIZE) {
                totalScore += 50;
            }

            return { score: totalScore, words: Array.from(formedWords) };
        }

        function submitWord() {
            if (!isDictionaryLoaded) {
                showMessageBox('Dictionary is still loading. Please wait...', 'info');
                return;
            }
            if (placedTiles.length === 0) {
                showMessageBox('No tiles placed yet!', 'error');
                return;
            }

            const tempBoard = JSON.parse(JSON.stringify(board));
            const tempPlacedTilesData = [];

            placedTiles.forEach(pTile => {
                const { r, c, tileObj } = pTile;
                const effectiveLetter = tileObj.assignedLetterForTurn || tileObj.letter;

                tempBoard[r][c] = {
                    letter: tileObj.letter,
                    points: tileObj.points,
                    assignedLetter: tileObj.assignedLetterForTurn || null
                };

                tempPlacedTilesData.push({
                    r: r,
                    c: c,
                    letter: effectiveLetter,
                    points: tileObj.points
                });
            });

            const result = validateAndScoreWords(tempBoard, tempPlacedTilesData);

            if (result) {
                playerScores[currentPlayer] += result.score;
                showMessageBox(`Player ${currentPlayer + 1} scored ${result.score} points! Words: ${result.words.join(', ')}`, 'success');
                
                if (result.score >= 100) {
                    playHundredPointsSound();
                    if (window.parent && typeof window.parent.awardBadge === 'function') {
                        window.parent.awardBadge('wordweaver100points', 'Word Weaver 100 Points');
                    } else {
                        console.warn("Parent window's awardBadge function not found.");
                    }
                } else if (result.score >= 50) {
                    playFiftyPointsSound();
                    if (window.parent && typeof window.parent.awardBadge === 'function') {
                        window.parent.awardBadge('wordweaver50points', 'Word Weaver 50 Points');
                    } else {
                        console.warn("Parent window's awardBadge function not found.");
                    }
                } else {
                    playGotWordSound();
                }

                placedTiles.forEach(pTile => {
                    const { r, c, tileObj, tileElement } = pTile;

                    board[r][c] = {
                        letter: tileObj.letter,
                        points: tileObj.points,
                        assignedLetter: tileObj.assignedLetterForTurn || null
                    };

                    if (tileObj.letter === '_') {
                        tileObj.assignedLetterForTurn = null;
                    }

                    tileElement.dataset.permanent = 'true';
                    tileElement.draggable = false;
                    tileElement.removeEventListener('click', handleTileClick);

                    const cellElement = document.getElementById(`cell-${r}-${c}`);
                    if (cellElement) {
                        cellElement.innerHTML = '';
                        cellElement.appendChild(tileElement);
                    }
                });
                placedTiles = [];

                drawTilesToRack(currentPlayer, RACK_SIZE - playerRacks[currentPlayer].length);

                endTurn();
            } else {
                revertPlacedTiles();
                showMessageBox("Invalid word placement or word. Check rules and try again!", 'error');
                playNotWordSound();
            }
        }

        function revertPlacedTiles() {
            placedTiles.forEach(pTile => {
                const { r, c, tileObj, tileElement } = pTile;

                if (tileObj.letter === '_') {
                    tileObj.assignedLetterForTurn = null;
                    delete tileElement.dataset.assignedLetter;
                    tileElement.querySelector('.tile-letter-display').textContent = '';
                }
                playerRacks[currentPlayer].push(tileObj);

                board[r][c] = null;

                const cellElement = document.getElementById(`cell-${r}-${c}`);
                cellElement.innerHTML = '';
                const bonusType = currentBonusSquares[`${r},${c}`];
                if (bonusType) { cellElement.textContent = getBonusLabel(bonusType); }

                delete tileElement.dataset.tempRow;
                delete tileElement.dataset.tempCol;

                renderRack(currentPlayer);
                playMP3Sound();
                showMessageBox('Tile moved back to rack.', 'info');
            });
            placedTiles = [];
        }

        function endTurn() {
            currentPlayer = (currentPlayer + 1) % 2;
            updateGameDisplay();

            if (tileBag.length === 0 && playerRacks[currentPlayer].length === 0) {
                let winnerMessage;
                if (playerScores[0] > playerScores[1]) {
                    winnerMessage = "Player 1 wins!";
                } else if (playerScores[1] > playerScores[0]) {
                    winnerMessage = `${gameMode === 'one-player' ? 'AI' : 'Player 2'} wins!`;
                } else {
                    winnerMessage = "It's a tie!";
                }

                showModal(`Game Over! Player 1: ${playerScores[0]} points, Player ${player2Label.textContent}: ${player2ScoreElement.textContent} points. ${winnerMessage}`, () => {
                    gameWrapper.classList.add('hidden');
                    mainMenu.classList.remove('hidden');
                });
            } else if (placedTiles.length > 0) {
                revertPlacedTiles();
            }

            if (gameMode === 'one-player' && currentPlayer === 1) {
                setTimeout(makeAIMove, 1500);
            }
        }

        function shuffleRack() {
            if (gameMode === 'one-player' && currentPlayer === 1) {
                showMessageBox("AI can't shuffle its rack. It plays automatically.", 'error');
                return;
            }
            if (!isDictionaryLoaded) { showMessageBox('Dictionary still loading. Please wait.', 'info'); return; }
            shuffleArray(playerRacks[currentPlayer]);
            renderRack(currentPlayer);
            showMessageBox('Rack shuffled!', 'info');
        }

        function showExchangeModal() {
            if (gameMode === 'one-player' && currentPlayer === 1) {
                showMessageBox("AI can't exchange tiles manually.", 'error');
                return;
            }
            if (!isDictionaryLoaded) { showMessageBox('Dictionary still loading. Please wait.', 'info'); return; }
            
            if (placedTiles.length > 0) {
                revertPlacedTiles();
            }

            selectedTilesForExchange = [];
            confirmExchangeBtn.disabled = true;
            exchangeTileSelectionContainer.innerHTML = '';

            if (playerRacks[currentPlayer].length === 0) {
                showMessageBox("Your rack is empty, no tiles to exchange!", 'error');
                return;
            }
            if (tileBag.length === 0) {
                showMessageBox('No tiles left in the bag to exchange!', 'error');
                return;
            }


            playerRacks[currentPlayer].forEach((tile, index) => {
                const tileElement = createTileElement(tile);
                tileElement.classList.add('rack-tile-for-exchange');
                tileElement.dataset.originalIndex = index;

                tileElement.draggable = false;
                tileElement.removeEventListener('dragstart', handleDragStart);
                tileElement.removeEventListener('dragend', handleDragEnd);
                tileElement.removeEventListener('click', handleTileClick);

                tileElement.addEventListener('click', (e) => {
                    const clickedTileInModal = e.currentTarget;
                    const originalIndex = parseInt(clickedTileInModal.dataset.originalIndex);
                    const tileData = playerRacks[currentPlayer][originalIndex];

                    const isSelected = selectedTilesForExchange.includes(tileData);

                    if (isSelected) {
                        selectedTilesForExchange = selectedTilesForExchange.filter(t => t !== tileData);
                        clickedTileInModal.classList.remove('selected-for-exchange');
                    } else {
                        selectedTilesForExchange.push(tileData);
                        clickedTileInModal.classList.add('selected-for-exchange');
                    }

                    const canConfirm = selectedTilesForExchange.length > 0 && tileBag.length >= selectedTilesForExchange.length;
                    confirmExchangeBtn.disabled = !canConfirm;

                    if (selectedTilesForExchange.length > tileBag.length) {
                        showMessageBox(`Not enough tiles in the bag (${tileBag.length}) to exchange ${selectedTilesForExchange.length} tiles. Select fewer.`, 'error');
                    } else if (selectedTilesForExchange.length > 0) {
                        messageBox.classList.remove('show');
                    } else {
                        showMessageBox('Please select at least one tile to exchange.', 'info');
                    }
                });
                exchangeTileSelectionContainer.appendChild(tileElement);
            });

            exchangeModal.style.display = 'flex';
        }

        function confirmExchange() {
            if (selectedTilesForExchange.length === 0) {
                showMessageBox('Please select at least one tile to exchange.', 'error');
                return;
            }
            if (tileBag.length < selectedTilesForExchange.length) {
                showMessageBox(`Cannot exchange ${selectedTilesForExchange.length} tiles. Only ${tileBag.length} tiles left in the bag.`, 'error');
                return;
            }

            const tilesToReturnToBag = [];
            playerRacks[currentPlayer] = playerRacks[currentPlayer].filter(tile => {
                const isSelected = selectedTilesForExchange.includes(tile);
                if (isSelected) {
                    tilesToReturnToBag.push(tile);
                    if (tile.letter === '_') {
                        tile.assignedLetterForTurn = null;
                    }
                }
                return !isSelected;
            });

            tilesToReturnToBag.forEach(tile => tileBag.push(tile));
            shuffleArray(tileBag);

            drawTilesToRack(currentPlayer, selectedTilesForExchange.length);

            showMessageBox(`Exchanged ${selectedTilesForExchange.length} tiles. Turn passed.`, 'info');
            exchangeModal.style.display = 'none';
            endTurn();
        }

        function cancelExchange() {
            exchangeModal.style.display = 'none';
            showMessageBox('Tile exchange cancelled.', 'info');
            renderRack(currentPlayer);
        }

        function showLetterSelectionModal(blankTileDomElement, onLetterSelected, onCancel) {
            currentBlankTileElement = blankTileDomElement;
            blankTileLetterSelectionContainer.innerHTML = '';

            ALPHABET.split('').forEach(char => {
                const letterButton = document.createElement('button');
                letterButton.classList.add('menu-button', 'w-12', 'h-12', 'flex', 'items-center', 'justify-center', 'text-xl', 'm-1');
                letterButton.textContent = char;
                letterButton.addEventListener('click', () => {
                    onLetterSelected(char);
                    blankTileModal.style.display = 'none';
                    currentBlankTileElement = null;
                });
                blankTileLetterSelectionContainer.appendChild(letterButton);
            });

            blankTileModal.style.display = 'flex';

            cancelBlankTileSelectionBtn.onclick = null;
            cancelBlankTileSelectionBtn.addEventListener('click', () => {
                onCancel();
                blankTileModal.style.display = 'none';
                currentBlankTileElement = null;
            }, { once: true });

            blankTileModal.onclick = null;
            blankTileModal.addEventListener('click', (event) => {
                if (event.target === blankTileModal) {
                    onCancel();
                    blankTileModal.style.display = 'none';
                    currentBlankTileElement = null;
                }
            }, { once: true });
        }

        function findAllPossibleWords(rack, currentBoard) {
            const possibleMoves = [];
            const existingBoardTiles = currentBoard.flat().filter(tile => tile !== null).length > 0;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] !== null) {
                        continue;
                    }

                    let isAnchor = false;
                    const neighbors = [[r-1, c], [r+1, c], [r, c-1], [r, c+1]];
                    if (!existingBoardTiles && r === 7 && c === 7) {
                        isAnchor = true;
                    } else if (existingBoardTiles) {
                        for (const [nr, nc] of neighbors) {
                            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && currentBoard[nr][nc] !== null) {
                                isAnchor = true;
                                break;
                            }
                        }
                    }

                    if (!isAnchor) continue;

                    ['horizontal', 'vertical'].forEach(direction => {
                        for (let numTiles = 1; numTiles <= rack.length; numTiles++) {
                            const combinations = getCombinations(rack, numTiles);

                            combinations.forEach(combo => {
                                const permutations = getPermutations(combo);
                                permutations.forEach(perm => {
                                    const tilesToSimulate = [...perm];

                                    let blankTileIndex = -1;
                                    for(let i = 0; i < tilesToSimulate.length; i++) {
                                        if (tilesToSimulate[i].letter === '_') {
                                            blankTileIndex = i;
                                            break;
                                        }
                                    }

                                    if (blankTileIndex !== -1) {
                                        ALPHABET.split('').forEach(char => {
                                            const originalTile = tilesToSimulate[blankTileIndex];
                                            const simulatedTile = { ...originalTile, assignedLetterForTurn: char };
                                            tilesToSimulate[blankTileIndex] = simulatedTile;

                                            const move = tryPlacementAndValidate(r, c, direction, tilesToSimulate, currentBoard, existingBoardTiles);
                                            if (move) {
                                                possibleMoves.push(move);
                                            }
                                        });
                                        tilesToSimulate[blankTileIndex] = { letter: '_', points: 0 };
                                    } else {
                                        const move = tryPlacementAndValidate(r, c, direction, tilesToSimulate, currentBoard, existingBoardTiles);
                                        if (move) {
                                            possibleMoves.push(move);
                                        }
                                    }
                                });
                            });
                        }
                    });
                }
            }
            return possibleMoves;
        }

        function tryPlacementAndValidate(r, c, direction, tilesToPlaceFromRack, currentBoard, existingBoardTiles) {
            const simulatedBoard = JSON.parse(JSON.stringify(currentBoard));
            const placedTempTilesData = [];

            let currentRow = r;
            let currentCol = c;
            let currentTileIndex = 0;

            while (currentTileIndex < tilesToPlaceFromRack.length) {
                if (currentRow >= BOARD_SIZE || currentCol >= BOARD_SIZE) {
                    return null;
                }
                if (simulatedBoard[currentRow][currentCol] !== null &&
                    !tilesToPlaceFromRack.some(t => t === simulatedBoard[currentRow][currentCol])) {
                    if (direction === 'horizontal') currentCol++;
                    else currentRow++;
                    continue;
                }
                if (simulatedBoard[currentRow][currentCol] !== null) {
                    return null;
                }

                const tile = tilesToPlaceFromRack[currentTileIndex];
                simulatedBoard[currentRow][currentCol] = {
                    letter: tile.letter,
                    points: tile.points,
                    assignedLetter: tile.assignedLetterForTurn || null
                };
                placedTempTilesData.push({
                    r: currentRow,
                    c: currentCol,
                    letter: tile.assignedLetterForTurn || tile.letter,
                    points: tile.points
                });

                if (direction === 'horizontal') currentCol++;
                else currentRow++;
                currentTileIndex++;
            }

            const result = validateAndScoreWords(simulatedBoard, placedTempTilesData);

            if (!existingBoardTiles && result) {
                const coversStartCell = placedTempTilesData.some(tile => tile.r === 7 && tile.c === 7);
                if (!coversStartCell) {
                    return null;
                }
            }

            if (result && result.score > 0) {
                return {
                    score: result.score,
                    word: result.words.join(', '),
                    tiles: placedTempTilesData,
                    rackUsed: tilesToPlaceFromRack
                };
            }
            return null;
        }

        function getCombinations(arr, k) {
            const result = [];
            function backtrack(combination, start) {
                if (combination.length === k) {
                    result.push([...combination]);
                    return;
                }
                for (let i = start; i < arr.length; i++) {
                    combination.push(arr[i]);
                    backtrack(combination, i + 1);
                    combination.pop();
                }
            }
            backtrack([], 0);
            return result;
        }

        function getPermutations(arr) {
            if (arr.length === 0) return [[]];
            if (arr.length === 1) return [[arr[0]]];

            const result = [];
            arr.forEach((item, i) => {
                const remaining = arr.filter((_, index) => index !== i);
                const permutationsOfRemaining = getPermutations(remaining);
                permutationsOfRemaining.forEach(p => {
                    result.push([item, ...p]);
                });
            });
            return result;
        }


        function makeAIMove() {
            showMessageBox("AI is thinking...", 'info');

            const aiRack = playerRacks[currentPlayer];
            let chosenMove = null;
            let possibleMoves = [];

            aiRack.forEach(tile => {
                if (tile.letter === '_') {
                    tile.assignedLetterForTurn = null;
                }
            });

            if (aiDifficulty === 'easy') {
                possibleMoves = findAllPossibleWords(aiRack, board).filter(move => move.rackUsed.length === 1);

                if (possibleMoves.length > 0) {
                    chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }

            } else if (aiDifficulty === 'medium') {
                possibleMoves = findAllPossibleWords(aiRack, board).filter(move => move.rackUsed.length <= 2);

                const highScoringMoves = possibleMoves.filter(move => move.score >= 5);
                if (highScoringMoves.length > 0) {
                    chosenMove = highScoringMoves.reduce((best, current) => {
                        return current.score > best.score ? current : best;
                    }, { score: -1 });
                } else if (possibleMoves.length > 0) {
                    chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }

            } else if (aiDifficulty === 'hard') {
                possibleMoves = findAllPossibleWords(aiRack, board);
                if (possibleMoves.length > 0) {
                    chosenMove = possibleMoves.reduce((best, current) => {
                        return current.score > best.score ? current : best;
                    }, { score: -1 });
                }
            }

            setTimeout(() => {
                if (chosenMove && chosenMove.score > 0) {
                    const playedTilesInfo = chosenMove.tiles;
                    const tilesToRemoveFromRack = chosenMove.rackUsed;

                    tilesToRemoveFromRack.forEach(playedTileObj => {
                        const index = playerRacks[currentPlayer].indexOf(playedTileObj);
                        if (index > -1) {
                            playerRacks[currentPlayer].splice(index, 1);
                        }
                    });

                    playedTilesInfo.forEach(tileData => {
                        const originalTileObj = tilesToRemoveFromRack.find(t =>
                            (t.letter === '_' && t.assignedLetterForTurn === tileData.letter) ||
                            (t.letter === tileData.letter && t.points === tileData.points)
                        );

                        board[tileData.r][tileData.c] = {
                            letter: originalTileObj ? originalTileObj.letter : tileData.letter,
                            points: originalTileObj ? originalTileObj.points : tileData.points,
                            assignedLetter: originalTileObj ? originalTileObj.assignedLetterForTurn : null
                        };
                        if (originalTileObj && originalTileObj.letter === '_') {
                            originalTileObj.assignedLetterForTurn = null;
                        }

                        const cellElement = document.getElementById(`cell-${tileData.r}-${tileData.c}`);
                        cellElement.innerHTML = '';
                        const permanentTileElement = createTileElement(board[tileData.r][tileData.c]);
                        permanentTileElement.dataset.permanent = 'true';
                        permanentTileElement.draggable = false;
                        permanentTileElement.removeEventListener('click', handleTileClick);
                        cellElement.appendChild(permanentTileElement);
                    });

                    playerScores[currentPlayer] += chosenMove.score;
                    showMessageBox(`AI played: ${chosenMove.word} for ${chosenMove.score} points!`, 'success');
                    
                    if (chosenMove.score >= 100) {
                        playHundredPointsSound();
                    } else if (chosenMove.score >= 50) {
                        playFiftyPointsSound();
                    } else {
                        playGotWordSound();
                    }

                    drawTilesToRack(currentPlayer, RACK_SIZE - playerRacks[currentPlayer].length);
                    endTurn();
                } else {
                    if (aiDifficulty === 'hard' && tileBag.length >= 1) {
                        const tilesToExchangeCount = Math.min(aiRack.length, tileBag.length);
                        if (tilesToExchangeCount > 0) {
                            showMessageBox(`AI exchanges ${tilesToExchangeCount} tiles (Hard mode - no scoring word found).`, 'info');
                            shuffleArray(aiRack);
                            const exchangedTiles = aiRack.splice(0, tilesToExchangeCount);
                            exchangedTiles.forEach(tile => {
                                tileBag.push(tile);
                                if (tile.letter === '_') tile.assignedLetterForTurn = null;
                            });
                            shuffleArray(tileBag);
                            drawTilesToRack(currentPlayer, tilesToExchangeCount);
                            endTurn();
                            return;
                        }
                    }
                    showMessageBox(`AI passes its turn (${aiDifficulty} mode - no scoring word found).`, 'info');
                    endTurn();
                }
            }, 1500);
        }

        submitWordBtn.addEventListener('click', submitWord);
        passTurnBtn.addEventListener('click', () => {
            if (gameMode === 'one-player' && currentPlayer === 1) {
                showMessageBox("You can't pass for it.", 'error');
                return;
            }
            if (placedTiles.length > 0) {
                showModal('You have tiles on the board. Do you want to pass your turn and return them to your rack?', () => {
                    revertPlacedTiles();
                    endTurn();
                });
            } else {
                showModal('Are you sure you want to pass your turn?', () => {
                    endTurn();
                });
            }
        });
        shuffleTilesBtn.addEventListener('click', shuffleRack);
        exchangeTilesBtn.addEventListener('click', showExchangeModal);
        newGameBtn.addEventListener('click', () => {
            showModal('Are you sure you want to start a new game? Current progress will be lost.', () => {
                gameWrapper.classList.add('hidden');
                mainMenu.classList.remove('hidden');
            });
        });

        onePlayerBtn.addEventListener('click', () => {
            if (!isDictionaryLoaded) { showMessageBox('Dictionary still loading. Please wait.', 'info'); return; }
            mainMenu.classList.add('hidden');
            difficultyMenu.classList.remove('hidden');
        });

        twoPlayerBtn.addEventListener('click', () => {
            if (!isDictionaryLoaded) { showMessageBox('Dictionary still loading. Please wait.', 'info'); return; }
            gameMode = 'two-player';
            mainMenu.classList.add('hidden');
            gameWrapper.classList.remove('hidden');
            initializeGame();
        });

        difficultyEasyBtn.addEventListener('click', () => {
            aiDifficulty = 'easy';
            gameMode = 'one-player';
            difficultyMenu.classList.add('hidden');
            gameWrapper.classList.remove('hidden');
            initializeGame();
        });

        difficultyMediumBtn.addEventListener('click', () => {
            aiDifficulty = 'medium';
            gameMode = 'one-player';
            difficultyMenu.classList.add('hidden');
            gameWrapper.classList.remove('hidden');
            initializeGame();
        });

        difficultyHardBtn.addEventListener('click', () => {
            aiDifficulty = 'hard';
            gameMode = 'one-player';
            difficultyMenu.classList.add('hidden');
            gameWrapper.classList.remove('hidden');
            initializeGame();
        });

        difficultyBackBtn.addEventListener('click', () => {
            difficultyMenu.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });

        confirmExchangeBtn.addEventListener('click', confirmExchange);
        cancelExchangeBtn.addEventListener('click', cancelExchange);
        closeExchangeModalBtn.addEventListener('click', cancelExchange);
        exchangeModal.addEventListener('click', (event) => {
            if (event.target === exchangeModal) {
                cancelExchange();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            loadDictionary();
        });
    </script>
</body>
</html>
